{% load static %}
<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Contrôle radiateur - Planning</title>
        <link rel="stylesheet" href="{% static 'bootstrap-5.3.8-dist/css/bootstrap.min.css' %}">
        <link rel="stylesheet" href="{% static 'css/planning.css' %}">
    </head>
    <body class="bg-light">
        <script id="schedule-data" type="application/json">{{ data|safe }}</script>
        <div class="container py-4 planning-container">
            <div class="d-flex flex-column gap-3 gap-md-4 mb-4">
                <div class="d-flex flex-column flex-md-row align-items-md-center justify-content-md-between gap-3">
                    <div>
                        <h1 class="h3 mb-1">Planning hebdomadaire</h1>
                        <p class="text-muted mb-0">Glissez et étirez les blocs pour définir les périodes d'activation.</p>
                    </div>
                    <div class="d-flex flex-column flex-sm-row gap-2 w-100 w-md-auto">
                        <a class="btn btn-outline-secondary flex-fill" href="/">Retour au tableau de bord</a>
                        <button class="btn btn-primary flex-fill" type="button" id="saveSchedule">Enregistrer le planning</button>
                    </div>
                </div>
                <div id="statusAlert" class="alert d-none" role="alert" aria-live="polite"></div>
            </div>

            <div class="planning-panel">
                <div class="day-switcher">
                    <button class="btn btn-outline-secondary day-switcher-btn" type="button" id="prevDay" aria-label="Jour précédent">
                        <span aria-hidden="true">&larr;</span>
                    </button>
                    <div class="day-switcher-label text-center">
                        <div class="fw-semibold" id="currentDayLabel">Lundi</div>
                        <div class="text-muted small">Touchez un bloc pour le déplacer ou le redimensionner.</div>
                    </div>
                    <button class="btn btn-outline-secondary day-switcher-btn" type="button" id="nextDay" aria-label="Jour suivant">
                        <span aria-hidden="true">&rarr;</span>
                    </button>
                </div>

                <div class="timeline-wrapper">
                    <div class="timeline-hours" id="timelineHours"></div>
                    <div class="timeline-track" id="dayTrack" data-day="monday"></div>
                </div>

                <div class="mt-3 d-flex gap-2">
                    <button class="btn btn-outline-primary flex-fill" type="button" id="addSlotButton">Ajouter un créneau</button>
                    <button class="btn btn-outline-danger flex-fill" type="button" id="clearDayButton">Vider le jour</button>
                </div>
                <p class="text-muted small mt-3 mb-0">
                    Astuce&nbsp;: maintenez le doigt sur une zone vide pour dessiner un nouveau créneau.
                </p>
            </div>
        </div>

        <script src="{% static 'bootstrap-5.3.8-dist/js/bootstrap.bundle.min.js' %}"></script>
        <script>
            const DAYS = [
                { key: 'monday', label: 'Lundi' },
                { key: 'tuesday', label: 'Mardi' },
                { key: 'wednesday', label: 'Mercredi' },
                { key: 'thursday', label: 'Jeudi' },
                { key: 'friday', label: 'Vendredi' },
                { key: 'saturday', label: 'Samedi' },
                { key: 'sunday', label: 'Dimanche' },
            ];

            const MINUTES_IN_DAY = 24 * 60;
            const SLOT_MIN_DURATION = 15;
            const DEFAULT_SLOT_DURATION = 60;
            const HOUR_HEIGHT = 64;
            const MINUTE_HEIGHT = HOUR_HEIGHT / 60;

            const scheduleBoard = document.getElementById('dayTrack');
            const timelineHours = document.getElementById('timelineHours');
            const statusAlert = document.getElementById('statusAlert');
            const saveButton = document.getElementById('saveSchedule');
            const addButton = document.getElementById('addSlotButton');
            const clearButton = document.getElementById('clearDayButton');
            const prevButton = document.getElementById('prevDay');
            const nextButton = document.getElementById('nextDay');
            const currentDayLabel = document.getElementById('currentDayLabel');

            let statusTimeout = null;
            let currentDayIndex = 0;
            let activeInteraction = null;
            const CREATE_HOLD_DELAY = 200;
            const CREATE_MOVE_THRESHOLD = 8;

            function showStatus(message, type = 'info', autoHide = true) {
                statusAlert.textContent = message;
                statusAlert.className = `alert alert-${type}`;
                if (autoHide) {
                    if (statusTimeout) {
                        clearTimeout(statusTimeout);
                    }
                    statusTimeout = setTimeout(() => {
                        statusAlert.classList.add('d-none');
                    }, 3500);
                } else {
                    if (statusTimeout) {
                        clearTimeout(statusTimeout);
                        statusTimeout = null;
                    }
                }
                statusAlert.classList.remove('d-none');
            }

            function hideStatus() {
                statusAlert.classList.add('d-none');
                if (statusTimeout) {
                    clearTimeout(statusTimeout);
                    statusTimeout = null;
                }
            }

            function getCookie(name) {
                let cookieValue = null;
                if (document.cookie && document.cookie !== '') {
                    const cookies = document.cookie.split(';');
                    for (let i = 0; i < cookies.length; i += 1) {
                        const cookie = cookies[i].trim();
                        if (cookie.startsWith(name + '=')) {
                            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                            break;
                        }
                    }
                }
                return cookieValue;
            }

            function ensureScheduleStructure(rawData) {
                const schedule = {};
                DAYS.forEach(({ key }) => {
                    if (!rawData || !Array.isArray(rawData[key])) {
                        schedule[key] = [];
                    } else {
                        schedule[key] = rawData[key]
                            .filter((entry) => entry && typeof entry.start === 'string' && typeof entry.end === 'string')
                            .map((entry) => ({ start: entry.start, end: entry.end }));
                    }
                });
                return schedule;
            }

            function minutesToPixels(totalMinutes) {
                return totalMinutes * MINUTE_HEIGHT;
            }

            function clampMinutes(minutes) {
                return Math.max(0, Math.min(MINUTES_IN_DAY, minutes));
            }

            function snapMinutes(minutes, step = SLOT_MIN_DURATION) {
                return Math.round(minutes / step) * step;
            }

            function minutesToTime(minutes) {
                const hours = Math.floor(minutes / 60).toString().padStart(2, '0');
                const mins = Math.floor(minutes % 60).toString().padStart(2, '0');
                return `${hours}:${mins}`;
            }

            function timeToMinutes(timeString) {
                const [hours, minutes] = timeString.split(':');
                return Number.parseInt(hours, 10) * 60 + Number.parseInt(minutes, 10);
            }

            function pointerMinutes(event) {
                const rect = scheduleBoard.getBoundingClientRect();
                const offsetY = event.clientY - rect.top;
                return clampMinutes(offsetY / MINUTE_HEIGHT);
            }

            function sortSlots(slots) {
                return [...slots].sort((a, b) => (a.start < b.start ? -1 : a.start > b.start ? 1 : 0));
            }

            function renderHours() {
                timelineHours.innerHTML = '';
                for (let hour = 0; hour < 24; hour += 1) {
                    const hourRow = document.createElement('div');
                    hourRow.className = 'timeline-hour';
                    hourRow.textContent = `${hour.toString().padStart(2, '0')}:00`;
                    timelineHours.appendChild(hourRow);
                }
                const endMarker = document.createElement('div');
                endMarker.className = 'timeline-hour timeline-hour-end';
                endMarker.textContent = '24:00';
                timelineHours.appendChild(endMarker);
            }

            function updateDayNavigation() {
                currentDayLabel.textContent = DAYS[currentDayIndex].label;
                scheduleBoard.dataset.day = DAYS[currentDayIndex].key;
                prevButton.disabled = currentDayIndex === 0;
                nextButton.disabled = currentDayIndex === DAYS.length - 1;
            }

            function updateSlotElement(block, startMinutes, endMinutes) {
                const top = minutesToPixels(startMinutes);
                const height = Math.max(minutesToPixels(endMinutes - startMinutes), minutesToPixels(SLOT_MIN_DURATION));
                block.style.top = `${top}px`;
                block.style.height = `${height}px`;
                const timeLabel = block.querySelector('.slot-time');
                if (timeLabel) {
                    timeLabel.textContent = `${minutesToTime(startMinutes)} – ${minutesToTime(endMinutes)}`;
                }
            }

            function renderCurrentDay() {
                const dayKey = DAYS[currentDayIndex].key;
                const slots = currentSchedule[dayKey] || [];
                const sortedSlots = sortSlots(slots);
                currentSchedule[dayKey] = sortedSlots;
                scheduleBoard.innerHTML = '';

                sortedSlots.forEach((slot, index) => {
                    const startMinutes = timeToMinutes(slot.start);
                    const endMinutes = timeToMinutes(slot.end);

                    const block = document.createElement('div');
                    block.className = 'slot';
                    block.dataset.index = String(index);
                    block.innerHTML = `
                        <div class="slot-handle slot-handle-start" data-handle="start"></div>
                        <div class="slot-content">
                            <div class="slot-time">${slot.start} – ${slot.end}</div>
                            <button class="btn btn-sm btn-light slot-delete" type="button" data-action="delete" aria-label="Supprimer le créneau">
                                &times;
                            </button>
                        </div>
                        <div class="slot-handle slot-handle-end" data-handle="end"></div>
                    `;

                    updateSlotElement(block, startMinutes, endMinutes);
                    scheduleBoard.appendChild(block);
                });
            }

            function persistSchedule(successMessage = 'Planning enregistré.') {
                showStatus('Enregistrement en cours…', 'info', false);
                return fetch('/maj_json', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken'),
                    },
                    body: JSON.stringify(currentSchedule),
                })
                    .then((response) => {
                        if (!response.ok) {
                            throw new Error('Réponse invalide');
                        }
                        showStatus(successMessage, 'success');
                    })
                    .catch(() => {
                        showStatus("Erreur lors de l'enregistrement du planning.", 'danger');
                    });
            }

            function canPlaceSlot(dayKey, startMinutes, endMinutes, excludeIndex = null) {
                if (endMinutes - startMinutes < SLOT_MIN_DURATION) {
                    return false;
                }
                const slots = currentSchedule[dayKey] || [];
                for (let i = 0; i < slots.length; i += 1) {
                    if (excludeIndex !== null && i === excludeIndex) {
                        continue;
                    }
                    const existing = slots[i];
                    const existingStart = timeToMinutes(existing.start);
                    const existingEnd = timeToMinutes(existing.end);
                    if (Math.max(existingStart, startMinutes) < Math.min(existingEnd, endMinutes)) {
                        return false;
                    }
                }
                return true;
            }

            function findAvailableStart(dayKey, durationMinutes) {
                const slots = sortSlots(currentSchedule[dayKey] || []);
                let previousEnd = 0;
                for (let i = 0; i < slots.length; i += 1) {
                    const start = timeToMinutes(slots[i].start);
                    if (start - previousEnd >= durationMinutes) {
                        return previousEnd;
                    }
                    previousEnd = timeToMinutes(slots[i].end);
                }
                if (MINUTES_IN_DAY - previousEnd >= durationMinutes) {
                    return previousEnd;
                }
                return null;
            }

            function addSlot(dayKey, startMinutes, endMinutes) {
                const slots = currentSchedule[dayKey] || [];
                slots.push({ start: minutesToTime(startMinutes), end: minutesToTime(endMinutes) });
                currentSchedule[dayKey] = sortSlots(slots);
                renderCurrentDay();
            }

            function deleteSlot(dayKey, index) {
                const slots = currentSchedule[dayKey] || [];
                if (index < 0 || index >= slots.length) {
                    return;
                }
                slots.splice(index, 1);
                currentSchedule[dayKey] = slots;
                renderCurrentDay();
            }

            function beginMove(event, dayKey, index, block) {
                const slots = currentSchedule[dayKey];
                const slot = slots[index];
                const startMinutes = timeToMinutes(slot.start);
                const endMinutes = timeToMinutes(slot.end);
                const duration = endMinutes - startMinutes;
                const pointerStart = pointerMinutes(event);
                const offset = pointerStart - startMinutes;

                const previousEnd = index > 0 ? timeToMinutes(slots[index - 1].end) : 0;
                const nextStart = index < slots.length - 1 ? timeToMinutes(slots[index + 1].start) : MINUTES_IN_DAY;

                activeInteraction = {
                    type: 'move',
                    pointerId: event.pointerId,
                    dayKey,
                    index,
                    element: block,
                    captureTarget: block,
                    duration,
                    offset,
                    minStart: previousEnd,
                    maxStart: nextStart - duration,
                    currentStart: startMinutes,
                    currentEnd: endMinutes,
                    originalStart: startMinutes,
                    originalEnd: endMinutes,
                };
                block.setPointerCapture(event.pointerId);
                event.preventDefault();
            }

            function beginResize(event, dayKey, index, block, handle) {
                const slots = currentSchedule[dayKey];
                const slot = slots[index];
                const startMinutes = timeToMinutes(slot.start);
                const endMinutes = timeToMinutes(slot.end);

                const previousEnd = index > 0 ? timeToMinutes(slots[index - 1].end) : 0;
                const nextStart = index < slots.length - 1 ? timeToMinutes(slots[index + 1].start) : MINUTES_IN_DAY;

                activeInteraction = {
                    type: handle === 'start' ? 'resize-start' : 'resize-end',
                    pointerId: event.pointerId,
                    dayKey,
                    index,
                    element: block,
                    captureTarget: block,
                    currentStart: startMinutes,
                    currentEnd: endMinutes,
                    originalStart: startMinutes,
                    originalEnd: endMinutes,
                    minStart: previousEnd,
                    maxEnd: nextStart,
                };
                block.setPointerCapture(event.pointerId);
                event.preventDefault();
            }

            function createTemporarySlotElement() {
                const block = document.createElement('div');
                block.className = 'slot slot-temporary';
                block.innerHTML = `
                    <div class="slot-handle slot-handle-start" data-handle="start"></div>
                    <div class="slot-content">
                        <div class="slot-time">--:-- – --:--</div>
                    </div>
                    <div class="slot-handle slot-handle-end" data-handle="end"></div>
                `;
                return block;
            }

            function beginCreateHold(event, dayKey) {
                const pointerId = event.pointerId;
                const anchorMinutes = snapMinutes(pointerMinutes(event));
                const holdTimeout = window.setTimeout(() => {
                    if (!activeInteraction || activeInteraction.type !== 'pending-create' || activeInteraction.pointerId !== pointerId) {
                        return;
                    }
                    const block = createTemporarySlotElement();
                    scheduleBoard.appendChild(block);
                    const start = activeInteraction.anchor;
                    const end = clampMinutes(start + SLOT_MIN_DURATION);
                    activeInteraction.type = 'create';
                    activeInteraction.element = block;
                    activeInteraction.captureTarget = scheduleBoard;
                    activeInteraction.currentStart = start;
                    activeInteraction.currentEnd = end;
                    updateSlotElement(block, start, end);
                    try {
                        scheduleBoard.setPointerCapture(pointerId);
                    } catch (error) {
                        /* Ignore */
                    }
                }, CREATE_HOLD_DELAY);

                activeInteraction = {
                    type: 'pending-create',
                    pointerId,
                    dayKey,
                    anchor: anchorMinutes,
                    holdTimeout,
                    startClientY: event.clientY,
                    captureTarget: null,
                };
            }

            function updateMove(event) {
                const pointer = clampMinutes(pointerMinutes(event) - activeInteraction.offset);
                const snapped = snapMinutes(pointer);
                const start = clampMinutes(Math.min(Math.max(snapped, activeInteraction.minStart), activeInteraction.maxStart));
                const end = clampMinutes(start + activeInteraction.duration);
                activeInteraction.currentStart = start;
                activeInteraction.currentEnd = end;
                updateSlotElement(activeInteraction.element, start, end);
                event.preventDefault();
            }

            function updateResizeStart(event) {
                const pointer = snapMinutes(clampMinutes(pointerMinutes(event)));
                const maxStart = activeInteraction.currentEnd - SLOT_MIN_DURATION;
                const start = Math.min(Math.max(pointer, activeInteraction.minStart), maxStart);
                activeInteraction.currentStart = start;
                updateSlotElement(activeInteraction.element, start, activeInteraction.currentEnd);
                event.preventDefault();
            }

            function updateResizeEnd(event) {
                const pointer = snapMinutes(clampMinutes(pointerMinutes(event)));
                const minEnd = activeInteraction.currentStart + SLOT_MIN_DURATION;
                const end = Math.max(Math.min(pointer, activeInteraction.maxEnd), minEnd);
                activeInteraction.currentEnd = end;
                updateSlotElement(activeInteraction.element, activeInteraction.currentStart, end);
                event.preventDefault();
            }

            function updateCreate(event) {
                const pointer = snapMinutes(clampMinutes(pointerMinutes(event)));
                let start = Math.min(activeInteraction.anchor, pointer);
                let end = Math.max(activeInteraction.anchor, pointer);
                if (end - start < SLOT_MIN_DURATION) {
                    end = start + SLOT_MIN_DURATION;
                }
                start = clampMinutes(start);
                end = clampMinutes(end);
                activeInteraction.currentStart = start;
                activeInteraction.currentEnd = end;
                updateSlotElement(activeInteraction.element, start, end);
                event.preventDefault();
            }

            function commitMove() {
                const { dayKey, index, currentStart, currentEnd } = activeInteraction;
                currentSchedule[dayKey][index] = {
                    start: minutesToTime(currentStart),
                    end: minutesToTime(currentEnd),
                };
                renderCurrentDay();
            }

            function commitResize() {
                const { dayKey, index, currentStart, currentEnd } = activeInteraction;
                currentSchedule[dayKey][index] = {
                    start: minutesToTime(currentStart),
                    end: minutesToTime(currentEnd),
                };
                renderCurrentDay();
            }

            function commitCreate() {
                const { dayKey, currentStart, currentEnd } = activeInteraction;
                if (!canPlaceSlot(dayKey, currentStart, currentEnd)) {
                    scheduleBoard.removeChild(activeInteraction.element);
                    showStatus('Créneau impossible à ajouter à cet endroit (chevauchement).', 'warning');
                    return;
                }
                addSlot(dayKey, currentStart, currentEnd);
            }

            function cancelActiveInteraction() {
                if (activeInteraction) {
                    if (activeInteraction.holdTimeout) {
                        window.clearTimeout(activeInteraction.holdTimeout);
                    }
                    if (activeInteraction.type === 'create' && activeInteraction.element && activeInteraction.element.parentNode) {
                        activeInteraction.element.parentNode.removeChild(activeInteraction.element);
                    }
                    if (activeInteraction.captureTarget && activeInteraction.pointerId !== undefined) {
                        try {
                            activeInteraction.captureTarget.releasePointerCapture(activeInteraction.pointerId);
                        } catch (error) {
                            /* Ignore */
                        }
                    }
                }
                activeInteraction = null;
            }

            scheduleBoard.addEventListener('pointerdown', (event) => {
                if (activeInteraction) {
                    return;
                }
                const dayKey = DAYS[currentDayIndex].key;
                const deleteButton = event.target.closest('button[data-action="delete"]');
                if (deleteButton) {
                    const block = deleteButton.closest('.slot');
                    if (!block) {
                        return;
                    }
                    const index = Number.parseInt(block.dataset.index, 10);
                    deleteSlot(dayKey, index);
                    return;
                }

                const handle = event.target.closest('[data-handle]');
                const block = event.target.closest('.slot');
                if (handle && block && !block.classList.contains('slot-temporary')) {
                    const index = Number.parseInt(block.dataset.index, 10);
                    beginResize(event, dayKey, index, block, handle.dataset.handle);
                    return;
                }

                if (block && !block.classList.contains('slot-temporary')) {
                    const index = Number.parseInt(block.dataset.index, 10);
                    beginMove(event, dayKey, index, block);
                    return;
                }

                if (event.target === scheduleBoard) {
                    beginCreateHold(event, dayKey);
                }
            });

            scheduleBoard.addEventListener('pointermove', (event) => {
                if (!activeInteraction || event.pointerId !== activeInteraction.pointerId) {
                    return;
                }
                if (activeInteraction.type === 'pending-create') {
                    if (Math.abs(event.clientY - activeInteraction.startClientY) > CREATE_MOVE_THRESHOLD) {
                        cancelActiveInteraction();
                        return;
                    }
                    activeInteraction.anchor = snapMinutes(pointerMinutes(event));
                    return;
                }
                if (activeInteraction.type === 'move') {
                    updateMove(event);
                } else if (activeInteraction.type === 'resize-start') {
                    updateResizeStart(event);
                } else if (activeInteraction.type === 'resize-end') {
                    updateResizeEnd(event);
                } else if (activeInteraction.type === 'create') {
                    updateCreate(event);
                }
            });

            scheduleBoard.addEventListener('pointerup', (event) => {
                if (!activeInteraction || event.pointerId !== activeInteraction.pointerId) {
                    return;
                }
                if (activeInteraction.type === 'pending-create') {
                    cancelActiveInteraction();
                    return;
                }
                if (activeInteraction.type === 'move') {
                    commitMove();
                } else if (activeInteraction.type === 'resize-start' || activeInteraction.type === 'resize-end') {
                    commitResize();
                } else if (activeInteraction.type === 'create') {
                    if (activeInteraction.currentEnd - activeInteraction.currentStart < SLOT_MIN_DURATION) {
                        if (activeInteraction.element.parentNode) {
                            activeInteraction.element.parentNode.removeChild(activeInteraction.element);
                        }
                    } else {
                        commitCreate();
                    }
                }
                cancelActiveInteraction();
            });

            scheduleBoard.addEventListener('pointercancel', () => {
                if (!activeInteraction) {
                    return;
                }
                if (activeInteraction.type === 'pending-create') {
                    cancelActiveInteraction();
                    return;
                }
                if (activeInteraction.type === 'create' && activeInteraction.element.parentNode) {
                    activeInteraction.element.parentNode.removeChild(activeInteraction.element);
                } else if (activeInteraction.type !== 'create' && activeInteraction.element) {
                    updateSlotElement(
                        activeInteraction.element,
                        activeInteraction.originalStart,
                        activeInteraction.originalEnd,
                    );
                }
                cancelActiveInteraction();
            });

            saveButton.addEventListener('click', () => {
                persistSchedule();
            });

            addButton.addEventListener('click', () => {
                const dayKey = DAYS[currentDayIndex].key;
                const availableStart = findAvailableStart(dayKey, DEFAULT_SLOT_DURATION);
                if (availableStart === null) {
                    showStatus('Aucun créneau disponible. Supprimez ou réduisez un bloc existant.', 'warning');
                    return;
                }
                const start = snapMinutes(availableStart);
                let end = start + DEFAULT_SLOT_DURATION;
                if (end > MINUTES_IN_DAY) {
                    end = MINUTES_IN_DAY;
                }
                addSlot(dayKey, start, end);
                showStatus('Nouveau créneau ajouté. Ajustez-le avec un glisser-déposer.', 'info');
            });

            clearButton.addEventListener('click', () => {
                const dayKey = DAYS[currentDayIndex].key;
                if (!currentSchedule[dayKey] || currentSchedule[dayKey].length === 0) {
                    return;
                }
                const confirmation = window.confirm('Supprimer tous les créneaux de ce jour ?');
                if (!confirmation) {
                    return;
                }
                currentSchedule[dayKey] = [];
                renderCurrentDay();
                showStatus('Tous les créneaux ont été supprimés pour ce jour.', 'info');
            });

            prevButton.addEventListener('click', () => {
                if (currentDayIndex > 0) {
                    currentDayIndex -= 1;
                    updateDayNavigation();
                    renderCurrentDay();
                }
            });

            nextButton.addEventListener('click', () => {
                if (currentDayIndex < DAYS.length - 1) {
                    currentDayIndex += 1;
                    updateDayNavigation();
                    renderCurrentDay();
                }
            });

            const rawSchedule = JSON.parse(document.getElementById('schedule-data').textContent || '{}');
            let currentSchedule = ensureScheduleStructure(rawSchedule);

            renderHours();
            updateDayNavigation();
            renderCurrentDay();
            hideStatus();
        </script>
    </body>
</html>
